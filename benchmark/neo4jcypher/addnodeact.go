package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"math/rand"
	"net/http"
	"strings"
	"sync"
	"time"

	gin "datatom/gin.v1"
)

type stateX struct {
	Statement string `json:"statement"`
}

type AutoGenerated struct {
	Statements []stateX `json:"statements"`
}

var (
	BASIC   = "basic"
	COMPANY = "cop"
	ACTOR   = "act"
)

func HttpGet(ip string, port int, uri string, body string) (response []byte, err error) {
	url := fmt.Sprintf("http://%s:%d%s",
		ip,
		port,
		uri)

	client := &http.Client{}

	req, err := http.NewRequest("POST", url, strings.NewReader(body))
	if err != nil {
		return []byte(""), err
	}

	req.SetBasicAuth("neo4j", "123456")
	req.Header.Set("Content-Type", "application/json")

	resp, err := client.Do(req)
	if err != nil {
		return []byte(""), err
	}

	defer resp.Body.Close()

	buf := new(bytes.Buffer)
	buf.ReadFrom(resp.Body)

	var errget error
	if resp.StatusCode != 200 {
		errget = errors.New(string(buf.Bytes()))
	}

	return buf.Bytes(), errget
}

// addNode
func addNode(nodeType string) error {
	r := rand.New(rand.NewSource(time.Now().UnixNano()))
	// 100个actor超级
	randNameNum := r.Intn(100)

	// 1000个随机演员
	randActNum := r.Intn(100)

	// 1000个随机公司
	randCopNum := r.Intn(100)
	ip := "192.168.50.5"
	port := 21811
	s := stateX{}

	switch nodeType {
	case BASIC:
		s.Statement = `
		CREATE (matrix1:Movie {tagline:"movie1",title:"The Matrix{random}",released:"2000"}) CREATE (actor1:Actor {name:"xxx1",gender:"female",age:"20"}) CREATE (actor2:Actor {name:"xxx2",gender:"male",age:"20"}) CREATE (company1:Company {name:"yyy1",date:"2019年02月13日"}) CREATE (company2:Company {name:"yyy2",date:"2019年02月13日"}) CREATE (b1:Boxoffice {total:"123,001"}) CREATE (movetype1:Movietype {movietype:"horrible"}) CREATE (matrix1)-[r1:INVITE]->(actor1) CREATE (matrix1)-[r2:INVITE]->(actor2) CREATE (company1)-[r3:INVEST]->(matrix1) CREATE (company2)-[r4:INVEST]->(matrix1) CREATE (matrix1)-[r5:EARN]->(b1) CREATE (matrix1)-[r6:MOVIETYPE]->(movetype1) RETURN matrix1,actor1,actor2,company1,company2,b1,movetype1
		`
	case COMPANY:
		// 新增关于2个公司的
		queryString_company := fmt.Sprintf("MATCH (company1:Company) WHERE company1.name=\"yyy1\" MATCH (company2:Company) WHERE company2.name=\"yyy2\" MATCH (movetype1:Movietype) WHERE movetype1.movietype=\"horrible\" CREATE (matrix1:Movie {tagline:\"movie2\",title:\"The Matrix%d\",released:\"2000\"}) CREATE (actor1:Actor {name:\"xxx%d\",gender:\"female\",age:\"20\"}) CREATE (actor2:Actor {name:\"xxx%d\",gender:\"male\",age:\"20\"}) CREATE (b1:Boxoffice {total:\"123,000\"}) CREATE (matrix1)-[r1:INVITE]->(actor1) CREATE (matrix1)-[r2:INVITE]->(actor2) CREATE (company1)-[r3:INVEST]->(matrix1) CREATE (company2)-[r4:INVEST]->(matrix1) CREATE (matrix1)-[r5:EARN]->(b1) CREATE (matrix1)-[r6:MOVIETYPE]->(movetype1) RETURN matrix1,actor1,actor2,company1,company2,b1,movetype1",
			randNameNum, randActNum, randActNum)
		s.Statement = queryString_company
	case ACTOR:
		// 新增关于2个演员的
		// queryString_actor := fmt.Sprintf("MATCH (actor1:Actor) WHERE actor1.name=\"xxx1\" MATCH (actor2:Actor) WHERE actor2.name=\"xxx2\" MATCH (movetype1:Movietype) WHERE movetype1.movietype=\"horrible\" CREATE (matrix1:Movie {tagline:\"movie1\",title:\"The Matrix%d\",released:\"2000\"}) CREATE (company1:Company {name:\"yyy%d\",date:\"2019年02月13日\"}) CREATE (company2:Company {name:\"yyy%d\",date:\"2019年02月13日\"}) CREATE (b1:Boxoffice {total:\"123,001\"}) CREATE (matrix1)-[r1:INVITE]->(actor1) CREATE (matrix1)-[r2:INVITE]->(actor2) CREATE (company1)-[r3:INVEST]->(matrix1) CREATE (company2)-[r4:INVEST]->(matrix1) CREATE (matrix1)-[r5:EARN]->(b1) CREATE (matrix1)-[r6:MOVIETYPE]->(movetype1) RETURN matrix1,actor1,actor2,company1,company2,b1,movetype1",
		// 	randNameNum, randCopNum, randCopNum)
		queryString_actor := fmt.Sprintf("MATCH (actor1) WHERE ID(actor1)=731277 MATCH (actor2) WHERE ID(actor2)=463798 MATCH (movetype1) WHERE ID(movetype1)=445206 CREATE (matrix1:Movie {tagline:\"movie1\",title:\"The Matrix%d\",released:\"2000\"}) CREATE (company1:Company {name:\"yyy%d\",date:\"2019年02月13日\"}) CREATE (company2:Company {name:\"yyy%d\",date:\"2019年02月13日\"}) CREATE (b1:Boxoffice {total:\"123,001\"}) CREATE (matrix1)-[r1:INVITE]->(actor1) CREATE (matrix1)-[r2:INVITE]->(actor2) CREATE (company1)-[r3:INVEST]->(matrix1) CREATE (company2)-[r4:INVEST]->(matrix1) CREATE (matrix1)-[r5:EARN]->(b1) CREATE (matrix1)-[r6:MOVIETYPE]->(movetype1) RETURN matrix1,actor1,actor2,company1,company2,b1,movetype1",
			randNameNum, randCopNum, randCopNum)
		fmt.Println(queryString_actor)
		s.Statement = queryString_actor
	default:
		err := errors.New("not supported type")
		return err
	}

	var ss []stateX
	body := gin.H{
		"statements": append(ss, s),
	}

	zz, _ := json.Marshal(body)

	_, err := HttpGet(ip, port, "/db/data/transaction/commit", string(zz))
	// fmt.Println(string(res))
	if err != nil {
		fmt.Println(err.Error())
		fmt.Println("failed")
		return err
	}
	return nil
}
func main() {
	x := 0
	var wg sync.WaitGroup
	for {
		if x < 100 {
			wg.Add(1)
			go func() {
				defer wg.Done()
				y := 0
				for {
					if y < 10000 {
						addNode("act")
						y++
					} else {
						break
					}
				}
			}()
			x++
		} else {
			break
		}
	}
	wg.Wait()
	fmt.Print("pass")
}
